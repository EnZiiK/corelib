package net.dohaw.corelib.helpers;

import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;

import java.text.DecimalFormat;

public class MathHelper {

    public enum CardinalDirection{
        N,
        NE,
        E,
        SE,
        S,
        SW,
        W,
        NW,
        INVALID;
    }

    public static double roundToPoint5(double x) {
        return Math.round(x * 2) / 2.0;
    }

    public static long secondsToTicks(double seconds) {
        return (long) (seconds*20);
    }

    public static double roundToPoint1(double x) {
        DecimalFormat df = new DecimalFormat("0.#");
        return Double.parseDouble(df.format(x));
    }

    public static CardinalDirection getCardinalDirection(Player player) {

        double rotation = (player.getLocation().getYaw() - 90) % 360;
        if (rotation < 0) {
            rotation += 360.0;
        }

        if (0 <= rotation && rotation < 22.5) {
            return CardinalDirection.N;
        } else if (22.5 <= rotation && rotation < 67.5) {
            return CardinalDirection.NE;
        } else if (67.5 <= rotation && rotation < 112.5) {
            return CardinalDirection.E;
        } else if (112.5 <= rotation && rotation < 157.5) {
            return CardinalDirection.SE;
        } else if (157.5 <= rotation && rotation < 202.5) {
            return CardinalDirection.S;
        } else if (202.5 <= rotation && rotation < 247.5) {
            return CardinalDirection.SW;
        } else if (247.5 <= rotation && rotation < 292.5) {
            return CardinalDirection.W;
        } else if (292.5 <= rotation && rotation < 337.5) {
            return CardinalDirection.NW;
        } else if (337.5 <= rotation && rotation < 360.0) {
            return CardinalDirection.N;
        } else {
            return CardinalDirection.INVALID;
        }

    }

    public static boolean isInt(String str) {
        try {
            Integer.parseInt(str);
        } catch (NumberFormatException e) {
            return false;
        }
        return true;
    }

    public static boolean isInt(String ...strs){
        for(String str : strs){
            if(!isInt(str)){
                return false;
            }
        }
        return true;
    }

    public static boolean isDouble(String str){
        try {
            Double.parseDouble(str);
        } catch (NumberFormatException e) {
            return false;
        }
        return true;
    }

    public static int getRandomInteger(int maximum, int minimum){
        return ((int) (Math.random()*(maximum - minimum))) + minimum;
    }

    public static Vector getVel(Location loc){
        double pitch = ((loc.clone().getPitch() + 90) * Math.PI) / 180;
        double yaw  = ((loc.clone().getYaw() + 90)  * Math.PI) / 180;
        double x = Math.sin(pitch) * Math.cos(yaw);
        double y = Math.sin(pitch) * Math.sin(yaw);
        double z = Math.cos(pitch);
        if(z>-0.2)z=-0.2;
        return new Vector(x, z, y);
    }

    /*
    public static Location lookAt(Location loc, Location lookat) {
        //Clone the loc to prevent applied changes to the input loc
        loc = loc.clone();

        // Values of change in distance (make it relative)
        double dx = lookat.getX() - loc.getX();
        double dy = lookat.getY() - loc.getY();
        double dz = lookat.getZ() - loc.getZ();

        // Set yaw
        if (dx != 0) {
            // Set yaw start value based on dx
            if (dx < 0) {
                loc.setYaw((float) (1.5 * Math.PI));
            } else {
                loc.setYaw((float) (0.5 * Math.PI));
            }
            loc.setYaw((float) loc.getYaw() - (float) Math.atan(dz / dx));
        } else if (dz < 0) {
            loc.setYaw((float) Math.PI);
        }

        // Get the distance from dx/dz
        double dxz = Math.sqrt(Math.pow(dx, 2) + Math.pow(dz, 2));

        // Set pitch
        loc.setPitch((float) -Math.atan(dy / dxz));

        // Set values, convert to degrees (invert the yaw since Bukkit uses a different yaw dimension format)
        loc.setYaw(-loc.getYaw() * 180f / (float) Math.PI);
        loc.setPitch(loc.getPitch() * 180f / (float) Math.PI);

        return loc;
    }*/

}
